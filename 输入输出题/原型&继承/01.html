<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
    </head>

    <body>
        <script>
            function Person(name) {
                this.name = name
            }
            var p2 = new Person('king');
            console.log(p2.__proto__) //Person.prototype
            console.log(p2.__proto__.__proto__) //Object.prototype
            console.log(p2.__proto__.__proto__.__proto__) // null
            // console.log(p2.__proto__.__proto__.__proto__.__proto__)//null后面没有了，报错
            // console.log(p2.__proto__.__proto__.__proto__.__proto__.__proto__)//null后面没有了，报错

            console.log(p2.constructor)//Person
            console.log(p2.prototype)//undefined p2是实例，没有prototype属性

            console.log(Person.constructor)//Function 一个空函数
            console.log(Person.prototype)//打印出Person.prototype这个对象里所有的方法和属性

            console.log(Person.prototype.constructor)//Person

            // Person.prototype.__proto__ 相当于 new 出来的对象(普通对象).__proto__
            console.log(Person.prototype.__proto__)// Object.prototype
            console.log(Person.__proto__) //Function.prototype
            console.log(Function.prototype.__proto__)//Object.prototype

            // 能 .出 __proto__ 的, 一定是普通对象
            // Function 和 Object 在这里都是构造函数, 本质上是函数, 所以往上找是 Function
            console.log(Function.__proto__)//Function.prototype
            console.log(Object.__proto__)//Function.prototype

            console.log(Object.prototype.__proto__)//null

            // 【构造函数】既可以通过 __proto__ 访问其原型链上的上层对象
            // 也可以通过 prototype 访问由它创建的实例的原型对象
            console.log(Function.__proto__ == Function.prototype);  // true
            console.log(Person.__proto__ == Person.prototype);  // false
        </script>
    </body>

</html>